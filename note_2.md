#### 1、函数：

为完成某一功能的程序指令（语句）的集合，称为函数

在Go中函数分为**自定义函数**、**系统函数**

基本语法：

```go
func 函数名 (形参列表) (返回值类型列表) {
    执行语句...
    return 返回值列表
}
```

1. 形参列表：表示函数的输入
2. 函数中的语句：表示为了实现某一功能代码块
3. 函数可以有返回值，也可以没有

##### 包：

utils.go //专门用于定义函数，让其它文件来调用

db.go // 专门定义对数据库的操作的函数

包的本质就是创建不同的文件夹，来存放程序文件

一个包往往对应一个文件夹

包的三大作用：

1. 区分相同名字的函数、变量等标识符
2. 当程序文件很多时，可以很好的管理项目
3. 控制函数、变量等访问范围，即作用域

包的相关说明：

- 打包基本语法

  package util

- 引入包的基本语法

  import "包的路径"  默认路径就是src/所以直接写路径就行

  GOPATH/src/完整包名

- 跨包使用必须大写，类似其他语言的public

- 调用的时候是包名.函数

包的使用细节：

1. 在给文件打包时吗，该包对应一个文件夹，比如utils文件夹对应的包名就是utils，文件的包名通常和文件所在的文件夹名一致，一般是小写字母

2. 当一个文件要使用其他包函数或变量时，需要引入对应的包

3. 引入方式1：import "包名"

4. 引入方式2：

   import (

   ​	"包名"

   ​	"包名"

   )

5. package 指令在文件第一行，然后是import指令

6. 在import包时，路径从$GOPATH的src下开始，不用带src，编译器会自动从src下开始引入

7. 为了让其他包的文件，可以访问到本包的函数，则该函数名的首字母需要大写，类似其他语言的public，这样才能跨包访问，比如utils.go

8. 在访问其他包函数时，其语法是 包名.函数名，比如这里的main.go文件中

9. 如果包名比较长，Go支持给包取名，注意细节：取别名后，原来的包名就不能使用了

   ```go
   import (
   	"fmt"
       util "go_code/utils"   // 起别名
   )
   ```

10. 在同一包下，不能有相同的函数名（也不能有相同的全局变量名），否则报重复定义

11. 如果你要编译成一个可执行程序文件，就需要将这个包声明为main，即package main 这个就是一个语法规范，如果你是写一个库，包名可以自定义

    说明：

    - 演示一个案例，项目的目录如右图
    - 编译的指令，在项目目录下，编译路径不需要带src，编译器会自动带
    - 编译时需要编译main包所在的文件夹
    - 项目的目录结构最好按照规范来组织
    - 编译后生成一个有默认名的可执行文件，在$GOPATH目录下，可以指定名字和目录，比如：放在bin目录下 D:\goproject>go build -o bin/my.exe go_code/project/main

##### 函数调用机制底层剖析：

栈区：（基本数据类型一般分配到栈区，编译器存在一个逃逸分析）

堆区：（引用数据类型一般说分配到堆区，编译器存在一个逃逸分析）

代码区：代码存放到这

说明：

- 在调用一个函数时，会给该函数分配一个新的空间，编译器会通过自身的处理让这个新的空间和其他栈的空间区分开
- 在每个函数对应的栈中，数据空间是空间的，不会混淆
- 当一个函数调用完毕（执行完毕）后，程序会销毁这个函数对应的栈空间

return语句：

```go
func 函数名（形参列表）（返回值类型列表）{
    语句...
    return 返回值列表
}
```

- 如果返回多个值，在接收时，希望忽略某个返回值，则使用_符号表示占位忽略
- 如果返回值只有一个（返回值类型列表）可以不写()

```go
res1,res2 := getSumAndSub(1,2)
// 如果只想获取一个值，可以这么做
_, res3 := getSumAndSub(1,2)
```

递归调用：

函数在函数体内调用了本身

- 递归必须向退出递归条件逼近，否则就是无限循环调用
- 执行一个函数时，就创建一个新的受保护的独立空间（新函数栈）
- 函数的局部变量是独立的，不会相互影响
- 当一个函数执行完毕，或者遇到return，就会返回，遵守谁调用，就将结果返回给谁，同时当函数执行完毕或返回时，该函数本身也会被系统摧毁

函数注意事项和细节：

1. 函数的形参列表可以是多个，返回值列表也可以是多个

2. 形参列表和返回值列表的数据类型可以是值类型和引用类型

3. 函数的命名遵循标识符命名规范，首字母不能是数字，首字母大写该函数可以被本包文件和其他包文件使用，类似public，首字母小写，只能被本包文件使用，其他包文件不能使用，类似private

4. 函数中的变量是局部的，函数外不生效

5. 基本数据类型和数组默认都是值传递，即进行值拷贝。在函数内修改，不会影响到原来的值

6. 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量

7. Go函数不支持重载

8. 在Go中，函数也是一种数据类型，可以赋值给一个变量，则该变量就是一个函数类型的变量，通过该变量可以对函数调用

9. 函数既然是一种数据类型，因此在Go中，函数可以作为形参，并且调用！ 

10. 为了简化数据类型定义，Go支持自定义数据类型

   基本语法：type 自定义数据类型名 数据类型  // 理解：相当于一个别名

   案例：type myInt int // 这是myInt就等价int来使用了

   案例：type mySum func(int，int) int  // 这时mySum就等价一个函数类型func (int，int) int

11. 支持对函数返回值命名

    ```go
    func cal(n1 int, n2 int) (sum int, sub int) {
        sum = n1 + n2
        sub = n1 - n2
        return
    }
    ```

12. 使用 _ 标识符，忽略返回值

13. Go支持可变参数

    ```go
    // 支持0到多个参数
    func sum(args... int) sum int {
    }
    // 支持1到多个参数
    func sum(n1 int, args... int) sum int {
    }
    ```

    说明：

    1. args是slice切片，通过args[index]可以访问到各个值
    2. 如果一个函数的形参列表中有可变参数，则可变参数需要放在形参列表最后

##### init函数：

每一个源文件都可以包含一个init函数，该函数会在main函数执行前，被Go运行框架调用，也就是说init会在main函数前被调用

细节：

1. 如果一个文件同时包含全局变量定义，init函数和main函数，则执行的流程是

   变量定义 -> init函数 -> main函数

2. init函数最主要的作用，就是完成一些初始化的工作，比如下面的案例

   比如初始化变量

##### 匿名函数：

Go支持匿名函数，如果我们某个函数只是希望使用一次，可以考虑使用匿名函数，匿名函数可以实现多次调用

- 使用方式1：

  在定义匿名函数时就直接调用

  ```go
  res1 := func (n1 int, n2 int) int {
      return n1 + n2
  }(10, 20)
  ```

- 使用方式2：

  将匿名函数赋给一个变量（函数变量），再通过该变量来调用匿名函数

  ```go
  a := func (n1 int, n2 int) int {
      return n1 - n2
  }
  res2 := a(10, 30)
  ```

- 全局匿名函数：

  ```go
  var (
  	// fun1就是一个全局匿名函数
      Fun1 = func (n1 int, n2 int) int {
          return n1 * n2
      }
  )
  ```

##### 闭包：

闭包就是一个函数和其相关的引用环境组合的一个整体（实体）

和js里的闭包有点像哈哈哈

```go
// 累加器
func AddUpper() func (int) int{
    var n int = 10
    return func (x int) int {
        n = n + x
        return n
    }
}

func main() {
    // 使用前面的代码
    f := AddUpper()
    fmt.Println(f(1))  // 11
    fmt.Println(f(1))  // 13
    fmt.Println(f(3))  // 16
}
```

说明和总结：

1. AddUpper是一个函数，返回的数据类型是fun (int) int

2. 闭包的说明

   返回的是一个匿名函数，但是这个匿名函数引用到函数外的n，因此这个匿名函数就和n形成一个整体，构成闭包

3. 可以理解为：闭包是类，函数是操作，n是字段。函数和它使用到n构成闭包

4. 当我们反复的调用f函数时，因为n是初始化一次，因此每调用一次就进行累计

5. 我们要搞清楚闭包的关键，就是分析出返回的函数它使用（引用）到那些变量，因为函数和它引用到的变量共同构成闭包

闭包案例：

1. 编写一个函数makeSuffix(suffix string) 可以接收一个文件后缀名(比如.jpg)，并返回一个闭包

2. 调用闭包，可以传入一个文件名，如果该文件名没有指定的后缀（比如.jpg），则返回文件名.jpg，如果已经有.jpg后缀，则返回原文件名

3. 要求使用闭包的方式完成

4. strings.HasSuffix，该函数可以判断某个字符串是否有指定的后缀

   ```go
   func makeSuffix(suffix string) func (string) string {
       return func (name string) string {
           // 如果 name 没有指定后缀，则加上，否则就返回原来的名字
           if !strings.HasSuffix(name, suffix) {
               return name + suffix
           }
           return name
       }
   }
   ```

说明：

1. 返回的函数和makeSuffix (suffix string) 和 suffix变量 和返回的函数组合成一个闭包，因为返回的函数引用到suffix这个变量
2. 体会一下闭包的好处，如果用传统的方法，也可以实现这个功能，但是传统方法需要每次都传入后缀名，比如.jpg，而闭包因为可以保留上次引用的某个值，所以我们传入一次就可以反复使用

##### 函数defer

在函数中经常需要创建资源（比如：数据库连接、文件句柄、锁等），为了在函数执行完毕后，及时释放资源，Go的设计者提供defer（延迟机制）

```go
func sum(n1 int, n2 int) int {
    // 当执行到defer时，暂时不执行，会将defer后面的语句压入到独立的栈（defer栈）
    // 当函数执行完毕后，再从defer栈，按照先入后出的方式出栈，执行
    defer fmt.Println("ok1 n1=",n1)  // 3
    defer fmt.Println("ok2 n2=",n2)  // 2
    res := n1 + n2  
    fmt.Println("ok3 res=",res)   // 1
    return res
}
func main(){
    res := sum(10,20)
    fmt.Println("res=",res)  // 4
}
```

细节：

1. 当Go执行到一个defer时，不会立即执行defer后的语句，而是将defer后的语句压入到一个栈中，然后继续执行函数的下一个语句
2. 当函数执行完毕后，再从defer栈中，依次从栈顶取出语句执行（注：遵守栈 先入后出的机制），所以同学们看到前面的案例输出的顺序
3. 在defer将语句放入到栈时，也会将相关的值拷贝同时入栈

defer最主要的价值在，当函数执行完毕后，可以及时释放函数创建的资源

```go
func test() {
    // 关闭文件资源
    file.openfile(文件名)
    defer file.close()
    // 其他代码
}
```

```go
func test() {
    // 释放数据库资源
    connect = openDatabse()
    defer connect.close()
    // 其他代码
}
```

说明：

1. 在Go编程中的通常做法是，创建资源后，比如（打开了文件，获取了数据库的链接，或者是锁资源），可以执行 defer.file.Close() defer connect.Close()
2. 在defer后，可以继续使用创建资源
3. 当函数完毕后，系统会依次从defer栈中，取出语句，关闭资源
4. 这种机制，非常简洁，程序员不用再为在什么时机关闭资源而烦心

##### 函数参数传递方式：

两种传递方式：

1. 值传递
2. 引用传递

其实不管值传递还是引用传递，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低

值类型和引用类型：

1. 值类型：基本数据类型 int 系列、float系列、bool、string、数组和结构体struct
2. 引用类型：指针、slice切片、map、管道chan、interface 等都是引用传递

##### 变量作用域：

1. 函数内部声明/定义的变量叫局部变量，作用域仅限于函数内部
2. 函数外部声明/定义的变量叫全局变量，作用域在整个包都有效，如果其首字母为大写，则作用域在整个程序有效
3. 如果变量是在一个代码块，比如for/if中，那么这个变量的作用域就在该代码块

```go
Name := "tom"  // var Name string  Name = "tom"会报错因为赋值语句只能在函数体内，函数外可以初始化不能赋值
```

##### Go字符串函数：

1. 统计字符串的长度，按字节len(str)
2. 字符串遍历，同时处理有中文的问题 r:=[]rune(str)
3. 字符串转整数：n, err := strconv.Atoi("12")
4. 整数转字符串 str = strconv.Itoa(123456)
5. 字符串 转[]byte: var bytes = []byte("hello go")
6. []byte 转 字符串 :str = string([]byte{97,98,99})
7. 10进制转2,8,16进制 :str=strconv.FormatInt(123,2)  // 1 -> 8, 16
8. 查找子串是否在指定进制的字符串中 :strings.Contains("seafood","foo")  // true
9. 统计一个字符串有几个指定的子串  :strings.Count("ceheese","e")  // 4
10. 不区分大小写的字符串比较（==是区分字母大小写的）:fmt.Println(strings.EqualFold("abc","Abc"))  // true
11. 返回子串在字符串中第一次出现的index值，如果没有返回-1 :strings.Index("NLT_abc","abc")   // 4
12. 返回子串在字符串最后一次出现的index，如果没有返回-1：strings.LastIndex("go golang","go")
13. 将指定的子串替换成另一个子串：strings.Replace("go go hello","go","go语言",n) n 可以指定你希望替换几个，如果n=-1表示全部替换
14. 按照指定的某个字符，为分割标识，将一个字符串拆分成字符串数组：strings.Split("hello,world",",")
15. 将字符串的字母进行大小写的转换：strings.ToLower("Go")  // go strings.ToUpper("Go")  // Go
16. 将字符串左右两边的空格去掉：strings.TrimSpace("  javascript     ")
17. 将字符串左右两边指定的字符去掉：strings.Trim("!hello! "," !")   将左右两边的！和" "去掉
18. 将字符串左边指定的字符去掉：strings.TrimLeft("! hello!","!")   将左边的！和" "去掉
19. 将字符串右边指定的字符去掉：strings.TrimRight("! hello!","!")  将右边的！和" "去掉
20. 判断字符串是否以指定的字符串开头 strings.HasPrefix("ftp://192.168.10.1","ftp")  
21. 判断字符串是否以指定的字符串结束 strings.HasSuffix("NLT_abc.jpg","abc")













































